#![feature(prelude_import)]
#![no_main]
#![no_std]
#![feature(min_specialization)]
#[prelude_import]
use core::prelude::rust_2021::*;
#[macro_use]
extern crate core;
#[macro_use]
extern crate compiler_builtins;
use core::ops::Deref;
use esp32c3_hal::{entry, riscv::register};
use rtt_target::{rtt_init_print, rprintln};
use panic_rtt_target as _;
use esp32c3::GPIO;
use esp32c3_hal::{
    riscv, prelude::*, peripherals::{self, Peripherals},
    system::{SoftwareInterrupt, SoftwareInterruptControl},
    interrupt::self,
};
use core::arch::asm;
use core::cell::RefCell;
use critical_section::Mutex;
use layout_derive::Layout;
use layout_trait::GetLayout;
struct Resources {
    gpio: GPIO,
}
static SWINT: Mutex<RefCell<Option<SoftwareInterruptControl>>> = Mutex::new(
    RefCell::new(None),
);
#[export_name = "main"]
pub unsafe fn __risc_v_rt__main() -> ! {
    let channels = {
        use core::mem::MaybeUninit;
        use core::ptr;
        use ::rtt_target::UpChannel;
        use ::rtt_target::DownChannel;
        use ::rtt_target::rtt::*;
        #[repr(C)]
        pub struct RttControlBlock {
            header: RttHeader,
            up_channels: [RttChannel; (1 + 0)],
            down_channels: [RttChannel; (0)],
        }
        #[used]
        #[no_mangle]
        #[export_name = "_SEGGER_RTT"]
        pub static mut CONTROL_BLOCK: MaybeUninit<RttControlBlock> = MaybeUninit::uninit();
        unsafe {
            ptr::write_bytes(CONTROL_BLOCK.as_mut_ptr(), 0, 1);
            let cb = &mut *CONTROL_BLOCK.as_mut_ptr();
            let mut name: *const u8 = core::ptr::null();
            name = "Terminal\u{0}".as_bytes().as_ptr();
            let mut mode = ::rtt_target::ChannelMode::NoBlockSkip;
            mode = ::rtt_target::ChannelMode::NoBlockSkip;
            cb.up_channels[0]
                .init(
                    name,
                    mode,
                    {
                        static mut _RTT_CHANNEL_BUFFER: MaybeUninit<[u8; 1024]> = MaybeUninit::uninit();
                        _RTT_CHANNEL_BUFFER.as_mut_ptr()
                    },
                );
            cb.header.init(cb.up_channels.len(), cb.down_channels.len());
            pub struct Channels {
                pub up: (UpChannel,),
            }
            Channels {
                up: (UpChannel::new(&mut cb.up_channels[0] as *mut _),),
            }
        }
    };
    ::rtt_target::set_print_channel(channels.up.0);
    ::rtt_target::print_impl::write_str(0, "Hello\n");
    let p = Peripherals::take();
    let system = p.SYSTEM.split();
    let sw_int = system.software_interrupt_control;
    critical_section::with(|cs| SWINT.borrow_ref_mut(cs).replace(sw_int));
    interrupt::enable(
            peripherals::Interrupt::FROM_CPU_INTR0,
            interrupt::Priority::Priority3,
        )
        .unwrap();
    critical_section::with(|cs| {
        SWINT
            .borrow_ref_mut(cs)
            .as_mut()
            .unwrap()
            .raise(SoftwareInterrupt::SoftwareInterrupt0);
    });
    ::rtt_target::print_impl::write_str(0, "We back!\n");
    loop {
        continue;
    }
}
#[doc(hidden)]
#[export_name = "FROM_CPU_INTR0"]
pub unsafe extern "C" fn __esp_hal_internal_FROM_CPU_INTR0_trampoline(
    context: &mut esp32c3_hal::trapframe::TrapFrame,
) {
    __esp_hal_internal_FROM_CPU_INTR0()
}
#[inline(always)]
fn __esp_hal_internal_FROM_CPU_INTR0() {
    critical_section::with(|cs| {
        SWINT
            .borrow_ref_mut(cs)
            .as_mut()
            .unwrap()
            .reset(SoftwareInterrupt::SoftwareInterrupt0);
    });
    ::rtt_target::print_impl::write_str(0, "Interrupt\n");
    let mut layout: Vec<layout_trait::Layout, 8> = Vec::new();
    let p = { Peripherals::steal() };
    let a = Resources { gpio: p.GPIO };
    a.get_layout(&mut layout);
    riscv::register::pmpaddr0::write(0x3fcc_f000 >> 2);
    riscv::register::pmpaddr1::write(0x3fcc_ffff >> 2);
    riscv::register::pmpaddr2::write(0x4000_0000 >> 2);
    riscv::register::pmpaddr3::write(0x4500_0000 >> 2);
    riscv::register::pmpaddr4::write(0xFFFF_FFFF >> 2);
    riscv::register::pmpaddr5::write(0x0);
    riscv::register::pmpaddr6::write(0x0);
    riscv::register::pmpaddr7::write(0x0);
    riscv::register::pmpaddr8::write(0x0);
    riscv::register::pmpaddr9::write(0x0);
    riscv::register::pmpaddr10::write(0x0);
    riscv::register::pmpaddr11::write(0x0);
    riscv::register::pmpaddr12::write(0x0);
    riscv::register::pmpaddr13::write(0x0);
    riscv::register::pmpaddr14::write(0x0);
    riscv::register::pmpaddr15::write(0x0);
    unsafe {
        riscv::register::pmpcfg0::set_pmp(
            0,
            riscv::register::Range::TOR,
            register::Permission::NONE,
            false,
        );
        riscv::register::pmpcfg0::set_pmp(
            1,
            riscv::register::Range::TOR,
            register::Permission::RWX,
            false,
        );
        riscv::register::pmpcfg0::set_pmp(
            2,
            riscv::register::Range::TOR,
            register::Permission::RWX,
            false,
        );
        riscv::register::pmpcfg0::set_pmp(
            3,
            riscv::register::Range::TOR,
            register::Permission::RWX,
            false,
        );
        riscv::register::pmpcfg1::set_pmp(
            0,
            riscv::register::Range::TOR,
            register::Permission::NONE,
            false,
        );
        riscv::register::pmpcfg1::set_pmp(
            1,
            riscv::register::Range::NA4,
            register::Permission::NONE,
            false,
        );
        riscv::register::pmpcfg1::set_pmp(
            2,
            riscv::register::Range::NA4,
            register::Permission::NONE,
            false,
        );
        riscv::register::pmpcfg1::set_pmp(
            3,
            riscv::register::Range::NA4,
            register::Permission::NONE,
            false,
        );
        riscv::register::pmpcfg2::set_pmp(
            0,
            riscv::register::Range::NA4,
            register::Permission::NONE,
            false,
        );
        riscv::register::pmpcfg2::set_pmp(
            1,
            riscv::register::Range::NA4,
            register::Permission::NONE,
            false,
        );
        riscv::register::pmpcfg2::set_pmp(
            2,
            riscv::register::Range::NA4,
            register::Permission::NONE,
            false,
        );
        riscv::register::pmpcfg2::set_pmp(
            3,
            riscv::register::Range::NA4,
            register::Permission::NONE,
            false,
        );
        riscv::register::pmpcfg3::set_pmp(
            0,
            riscv::register::Range::NA4,
            register::Permission::NONE,
            false,
        );
        riscv::register::pmpcfg3::set_pmp(
            1,
            riscv::register::Range::NA4,
            register::Permission::NONE,
            false,
        );
        riscv::register::pmpcfg3::set_pmp(
            2,
            riscv::register::Range::NA4,
            register::Permission::NONE,
            false,
        );
        riscv::register::pmpcfg3::set_pmp(
            3,
            riscv::register::Range::NA4,
            register::Permission::NONE,
            false,
        );
    }
    unsafe { riscv::register::mstatus::set_mpp(riscv::register::mstatus::MPP::User) }
    unsafe {
        asm!(
            "\n            auipc t0, 0\n            addi t0, t0, 14\n            csrw mepc, t0\n            mret\n        "
        );
    }
    unsafe {
        let mut a = 0x3fcc_f000 as *mut u32;
        *a = 40;
        let mut b = 0x3fcc_d000 as *mut u32;
        *b = 40;
    }
    unsafe {
        asm!("\n            ecall\n        ");
    }
    {
        esp32c3_hal::peripherals::Interrupt::FROM_CPU_INTR0;
    }
}
